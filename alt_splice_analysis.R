install.packages("seqinr")
install.packages("docstring")
library(seqinr)

#set paths
countTable_files<-"C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/countTables/"
countTable_path<-file.path(countTable_files)
test_results<-"C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/significance_tests/"
ms_files<-("C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/qbicdataset/MS_data/")
ms_path<-file.path(ms_files)
ms_ending<-"final_output.csv"
fasta_ending<-"_Neointrons_sp.fasta"
fasta_files<-("C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/qbicdataset/FASTA_data/")
fasta_path<-file.path(fasta_files)
ms_fasta_results<-"C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/MS_FASTA_search/"
result_path<-"C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/Results/"
metasheet<-read.csv("C:/Users/Rosa/Documents/Uni/7.Semester/Bachelorarbeit/alternative_splicing_analysis/MetaSheet_RNA_Seq_Samples.csv")

#set variables
splicing<-c("alt_3prime","alt_5prime","exon_skip","intron_retention","mult_exon_skip")
fillname<-"for_"
ending<-c(".csv")
alpha=0.05
groups<-metasheet$Group
cancer<-grep("tumour",groups)
normal<-grep("normal",groups)
num_cancer_samples<-length(cancer)
num_normal_samples<-length(normal)
outfile_names<-c("wilcoxon_test_and_multiple_corrections","significant genes for cancer")

df_to_csv<-function(df,csv){
  df_file=df
  df_file$genenames=rownames(df_file)
  write.csv(df_file,row.names = FALSE,file = csv)
}

csv_to_df<-function(csv){
  df<-read.csv(csv,row.names = "genenames")
  return(df)
}

preprocess_data<-function(data){
  keep<-c()
  for(i in c(1:dim(data)[1])){
    keep<-c(keep,var(as.integer(data[i, ]))!=0)
  }
  processed<-data[keep,]
  return(processed)
}

get_countMatrix<-function(splice){
  #' Read in a count matrix
  #'
  #' Reads in the count matrix of a given csv file, seperated by "," (normally generated by the python script gff3Parser.py)
  #'
  #' @param splice the splicing type, that maches the pattern of the csv file 
  #'
  getfile<-list.files(path=countTable_path,pattern=paste0(fillname,splice))
  file<-csv_to_df(paste0(countTable_files,getfile))
  processed<-preprocess_data(file)
  print(paste("all entries are the same",(dim(file)[1]-dim(processed)[1])))
  return(processed)

}

docstring(get_countMatrix)




wilcox_test<-function(countTable){
  #' Wilcoxon test between OvCa and OvN
  #'
  #' Performs two-sample Wilcoxon tests on vectors of OvCa and OvN data; the latter is also known as �Mann-Whitney� test.
  #'
  #' @param countTable the event count matrix for a certain splicing type
  #' @return The event count matrix containing the computed p-value will be returned.
  #'
  #' @details The formula interface is only applicable for the 2-sample tests and uses the wilcox.test of R.
  #' The countmatrix is seperated in OvCa and OvN samples for analysing the data by significant differences between the two cohorts.
  #' By the usage of wilcox.test(cancerCounts,normalCounts) a p-value is calculated.
  #' If the p-value is NaN because the eventcount is the same for all patients, the gene is removed from the final event count matrix.
  #' @references wilcox.test of R
  #' 
  rows_in_data<-dim(countTable)[1]
  pval<-c()
  Ca<-countTable[,cancer]
  N<-countTable[,normal]
  for(row in c(1:rows_in_data)){
    result<-wilcox.test(as.integer(Ca[row,]),as.integer(N[row,]))
    p_value=result$p.value
    pval<-c(pval,p_value)
    
    
    
  }
  countTable$p.value<-pval
  
  return(countTable)
}

docstring(wilcox_test)

order_df_by_pval<-function(df){
  #' Order data.frame by p-value
  #'
  #' A given data.frame is sorted in ascending order of the p-values.
  #'
  #' @param df the event count matrix for a certain splicing type, after appling the p-value of the wilcoxon test.
  #'
  #'
  
  #' 
  df<-df[order(df$p.value),]
  return(df)
}

docstring(order_df_by_pval)

bonf_correction<-function(df){
  #' Adjust bonferroni correction to data.frame
  #'
  #' The bonferroni correction is calculated for the event count matrix.
  #'
  #' @param df the event count matrix for a certain splicing type, after appling the p-value of the wilcoxon test.
  #' @references Haynes W. (2013) Bonferroni Correction. In: Dubitzky W., Wolkenhauer O., Cho KH., Yokota H. (eds) Encyclopedia of Systems Biology. Springer, New York, NY
  #'
  
  #' 
  m<-nrow(df)
  df$bonf<-p.adjust(df$p.value,method="bonferroni")
  return(df)
}
docstring(bonf_correction)

fdr<-function(df){
  #' Adjust bonferroni correction to data.frame
  #'
  #' The bonferroni correction is calculated for the event count matrix.
  #'
  #' @param df the event count matrix for a certain splicing type, after appling the p-value of the wilcoxon test.
  #' @details  The fdr method of Benjamini, Hochberg, and Yekutieli control the false discovery rate, the expected proportion of false discoveries amongst the rejected hypotheses. 
  #' The false discovery rate is a less stringent condition than the family-wise error rate, so these methods are more powerful than the others.
  #' @references 
  #' Benjamini, Y., and Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. Journal of the Royal Statistical Society Series B, 57, 289�300. http://www.jstor.org/stable/2346101.
  #' Benjamini, Y., and Yekutieli, D. (2001). The control of the false discovery rate in multiple testing under dependency. Annals of Statistics, 29, 1165�1188. doi: 10.1214/aos/1013699998.
  #' @seealso p.adjust  (provided by R.)
  #'
  
  fdr<-p.adjust(df$p.value,method="fdr")
  df$fdr<-fdr
  return(df)
}
docstring(fdr)

round_value<-function(value,digits=6){
  #' Round value to 6 digits
  #'
  #' Round all values in a certain column of a data.frame to 6 digits
  #'
  #' @param value column of a data.frame
  #' @param digits nteger indicating the number of decimal places (round)  to be used. Default 6.
  #' @details  Uses the function round provided by R. 
  #' @seealso round 
  for(v in c(1:length(value))){
    value[v]<-round(value[v],digits)
    
  }
  return(value)
  
}

docstring(round_value)


round_val_for_csv<-function(df){
  #' Round different values of a data.frame
  #'
  #' Round all values in a certain column of a data.frame to 6 digits
  #'
  #' @param df count matrix containing p-value, bonferroni correction and fdr.
  #'
  #' @details  Uses the function round_value 
  #' @seealso round_value
  df$p.value<-round_value(df$p.value)
  df$bonf<-round_value(df$bonf)
  df$fdr<-round_value(df$fdr)
  return(df)
  
}

docstring(round_val_for_csv)

add_splicing<-function(df,splice){
  #' Add splicing to data.frame
  #'
  #' Make a new column of the data.frame that contains the type of the alternative splice event.
  #'
  #' @param df count matrix
  #' @param splice type of alternative splicing
  #' 
  splice_type<-c()
  for(i in c(1:nrow(df))){
    splice_type<-c(splice_type,splice)
  }
  df<-data.frame(df,splice_type)
  return(df)
}

docstring(add_splicing)


#significance for cancer
sig_ca<-function(df){
  #' Geneevents occuring more often in cancer
  #'
  #' Calculates the genes, that have more events in OvCa sample than in OvN
  #'
  #' @param df count matrix
  #' 
  #' 
  df<-df[(rowSums(df[,cancer])/num_cancer_samples)>(rowSums(df[,normal])/num_normal_samples),]
  return(df)
}




#fdr smaller than alpha
sig_alpha<-function(df){
  #' Round value to 6 digits
  #'
  #' Round all values in a certain column of a data.frame to 6 digits
  #'
  #' @param value column of a data.frame
  #' @param digits nteger indicating the number of decimal places (round)  to be used. Default 6.
  #' @details  Uses the function round provided by R. 
  #' @seealso round
  #' 
  df<-df[is.nan(df$fdr)==FALSE & df$fdr<=alpha,]
  return(df)
}

read_fasta_in<-function(fasta){
  fasta_file<-read.fasta(file=paste0(fasta_files,fasta),as.string = TRUE)
  return(fasta_file)
}


remove_oxidation<-function(df){
  seq<-df$sequence
  sequences<-c()
  for(s in c(1:length(seq))){
    value<-gsub("[(Oxidation)]","",seq[s])
    sequences<-c(sequences,value)
    
    
  }
  return(sequences)
  
} 
add_name<-function(df,name){
  file_name<-c()
  for(i in c(1:nrow(df))){
    file_name<-c(file_name,name)
  }
  df<-data.frame(df,file_name)
  return(df)
}

MS_Search<-function(file){
  ms<-read.csv(paste0(ms_files,file))
  accessions<-ms$accessions
  contained<-c()
  for(a in c(1:length(accessions))){
    if(regexpr(";",accessions[a])==-1 & regexpr("ENSG0",accessions[a])!=-1){
      contained<-c(contained,a)
    }
  }
  df<-ms[contained,] 
  seq<-remove_oxidation(df)
  rep_name<-c()
  scan<-c()
  for(row in c(1:dim(df)[1])){
    scan<-c(scan,strsplit(toString(df$spectrum_reference[row])," ")[[1]][3])
    reps<-strsplit(toString(df$file_origin[1]),"/")[[1]]
    rep_name<-c(rep_name,reps[length(reps)])
  }
  df$sequence<-NULL
  df$peptide<-seq
  final_df<-data.frame(df$peptide,df$accessions,scan,rep_name)
  colnames(final_df)<-c("peptide","accessions","scan","rep_name")
  return(final_df)
}



fasta_Search<-function(fasta,ms_data){
  contained_ms<-c()
  contained_fasta<-c()
  counter<-0
  #get the peptid and its corresponding accession of the ms data
  for(row in c(1:dim(ms_data)[1])){
    pattern=ms_data[row,1]          #peptidsequence of the MS data
    gene=ms_data[row,2]             #accession of the MS data
    matched_seq<-c()
    matched_seq<-grep(pattern,toupper(fasta))
    
    if(length(matched_seq)!=0){
      for(m in c(1:length(matched_seq))){
        if(gene==attr(fasta[matched_seq[m]],"name")){
          contained_ms<-c(contained_ms,row)
          contained_fasta<-c(contained_fasta,matched_seq[m])
          
        }
      }
    }
    else{
      counter<-counter+1
    }
  }
  
  fasta_res<-fasta[contained_fasta]
  ms_res<-ms_data[contained_ms,]
  if(length(fasta_res)!=0){
    annot<-c()
    for(entry in c(1:length(fasta_res))){annot<-c(annot,getAnnot(fasta_res[[entry]]))}
    seq<-getSequence(fasta_res,as.string = TRUE)
    sequence<-c()
    for(entry in c(1:length(seq))){sequence<-c(sequence,toupper(seq[[entry]][[1]]))}
    splice_type<-vector(,length(fasta_res))
    for(splice in c(1:length(splicing))){
      a<-grep(splicing[splice],annot)
      splice_type[a]=splicing[splice]
    }
    genes<-attr(fasta_res,"name")
    final_result<-data.frame(genes,splice_type,ms_res$peptid,sequence,annot,ms_res$scan,ms_res$rep_name)
    colnames(final_result)<-c("genenames","splice_type","peptide","sequence","annotation","scan","rep_name")

  }
  else{
    final_result<-data.frame()
  }
  return(final_result)
}

find_gene<-function(search,test,splice){
  if(dim(test)[1]!=0 & dim(search)[1]!=0){
  contained_test<-c()
  contained_search<-c()
  not_found<-0
  for(g in c(1:dim(search)[1])){
    if(search$splice_type[g]==splice){
      matched_seq<-regexpr(search$genenames[g],test$genenames)
      matched<-c()
      for(m in c(1:length(matched_seq))){
        if(matched_seq[m]!=-1){
          matched<-c(matched,m)
        }
      }
    
      if(length(matched!=0)){
        contained_test<-c(contained_test,matched)
        contained_search<-c(contained_search,g)
      }
      else{
        not_found<-not_found+1
      }
    }
  }
  print(paste("not found",not_found))
  df<-test[contained_test,]
  df$genenames<-search$genenames[contained_search]
  df$splice_type<-search$splice_type[contained_search]
  df$peptide<-search$peptide[contained_search]
  df$sequence<-search$sequence[contained_search]
  df$annotation<-search$annotation[contained_search]
  df$scan<-search$scan[contained_search]
  df$rep_name<-search$rep_name[contained_search]
  df$file_name<-search$file_name[contained_search]
 
  }
  else{
    df<-test
    df$genenames<-logical(0)
    df$splice_type<-logical(0)
    df$peptide<-logical(0)
    df$sequence<-logical(0)
    df$annotation<-logical(0)
    df$scan<-logical(0)
    df$rep_name<-logical(0)
    df$file_name<-logical(0)
    
  }
  return(df)
}


apply_isoform<-function(df){
  iso1<-"iso1"
  iso2<-"iso2"
  count_iso1<-0
  count_iso2<-0
  count_both<-0
  count_none<-0
  isoforms<-c()
  sum<-dim(df)[1]
  for(entry in c(1:dim(df)[1])){
    if(regexpr(iso2,df$annotation[entry])!=-1 & regexpr(iso1,df$annotation[entry])==-1){
      isoforms<-c(isoforms,iso2)
      count_iso2<-count_iso2+1
      
    }
    if(regexpr(iso2,df$annotation[entry])==-1 & regexpr(iso1,df$annotation[entry])!=-1){
      count_iso1<-count_iso1+1
      isoforms<-c(isoforms,iso1)
      
    }
    if(regexpr(iso2,df$annotation[entry])!=-1 & regexpr(iso1,df$annotation[entry])!=-1){
      count_both<-count_both+1
      isoforms<-c(isoforms,"both")
      
    }
    if(regexpr(iso2,df$annotation[entry])==-1 & regexpr(iso1,df$annotation[entry])==-1){
      count_none<-count_none+1
      isoforms<-c(isoforms,"none")
      
    }
  }
  app_sum<-count_none+count_both+count_iso2+count_iso1
  df$isoform<-isoforms
  return(df)
}

get_one_isoform<-function(df){
  peptides<-levels(df$peptide)
  one_isoform<-data.frame()
  for(seq in c(1:length(peptides))){
  sequences<-df[df$peptide==peptides[seq],]
  isoform<-sequences$isoform
  sequence<-sequences$sequence
  different=TRUE
  if(length(isoform)!=1){
    equal=TRUE
    
  for(i in c(1:(length(isoform)-1))){
    if(isoform[i]!=isoform[i+1] | isoform[i]=="both"){
      equal=FALSE
      break;
    }
   if(equal & sequence[i]==sequence[i+1]){
     different=FALSE
     break;
   }
  
  }
  }
  
  else{
    if(length(isoform)==1 & isoform[1]!="both"){
      equal=TRUE
      
    }
    else{
      equal=FALSE
      
    }
  }
  if(equal & different){
    one_isoform<-rbind.data.frame(one_isoform,sequences)
  }
  else{
    if(equal){
      one_isoform<-rbind.data.frame(one_isoform,sequences[1,])
    }
    else{
    print(isoform)
    }
  }
  }
  write.csv(one_isoform,paste0(result_path,"peptides in one isoform.csv"),row.names = FALSE)
  return(one_isoform)
}


get_events<-function(gene){
  result<-data.frame()
  splice_type<-c()
  for(splice in c(1:length(splicing))){
    row<-c()
    data<-read.csv(paste0(test_results,outfile_names[1],"_",splicing[splice],ending))
    matched_gene<-regexpr(gene,data$genenames)
    matched<-c()
    for(m in c(1:length(matched_gene))){
      if(matched_gene[m]!=-1){
        matched<-c(matched,m)
      }
    }
    if(length(matched==1)){
      res<-data[matched,]
      splice_type<-c(splice_type,splicing[splice])
      result<-rbind.data.frame(result,res)
    }
  }
  result$splice_type<-splice_type
  return(result)
  
}

gene_other_splicetypes<-function(){
  isoforms<-read.csv(paste0(ms_fasta_results,"final_peptide_set.csv"))
  genes<-levels(isoforms$genenames)
  data<-data.frame()
  
  for (gene in c(1:length(genes))){
    df<-get_events(genes[gene])
    data<-rbind.data.frame(data,df)
  }
  colnames(data)<-c("genenames",colnames(data)[2:dim(data)[2]])
  write.csv(data,paste0(result_path,"genes_of_search_in_other_events.csv"),row.names = FALSE)
  return(data)
}

##main
main<-function(){
for(splice in c(1:length(splicing))){
 print(paste("wilcoxon test for",splicing[splice]))
  countTable<-get_countMatrix(splicing[splice])
  df<-wilcox_test(countTable)
  df<-order_df_by_pval(df)
  df<-bonf_correction(df)
  df<-fdr(df)
  df<-round_val_for_csv(df)
  sig<-sig_alpha(df)
  sigCa<-sig_ca(sig)
  df_to_csv(df,paste0(test_results,outfile_names[1],"_",splicing[splice],".csv"))
  df_to_csv(sigCa,paste0(test_results,outfile_names[2],"_",splicing[splice],".csv"))
  print(paste("number of genes in",splicing[splice],dim(df)[1]))
  print(paste("number of significant genes in",splicing[splice],dim(sig)[1]))
  print(paste("number of significant cancer genes in",splicing[splice],dim(sigCa)[1]))
  
}
  
  
  
  #search for every pair
  fastas<-list.files(path=fasta_path,pattern=fasta_ending)
  all_sigData<-data.frame()
  for(file in c(1:length(fastas))){
    print(fastas[file])
    fasta<-read_fasta_in(fastas[file])
    fasta_name<-gsub(fasta_ending,"",fastas[file])
    ms<-list.files(path=ms_path,pattern=fasta_name)
    print(ms)
    if(length(ms)!=0){
      data<-MS_Search(ms)
      print(paste(fasta_name, ": before FASTA Search different sequences", length(levels(data$peptide))))
      final<-fasta_Search(fasta,data)
      final<-add_name(final,ms)
      print(paste(fasta_name, ": after FASTA Search different sequences/different genes:", length(levels(final$peptide)),"/",length(levels(final$genenames))))
      write.csv(final,paste0(ms_fasta_results,fasta_name,"_search.csv"),row.names = FALSE)
      
    }
    sig_data<-data.frame()
    for(splice in c(1:length(splicing))){
      test<-read.csv(paste0(test_results,outfile_names[2],"_",splicing[splice],".csv")) #sig_gene_ca accessf
      data<-find_gene(final,test,splicing[splice])
      sig_data<-rbind.data.frame(sig_data,data)
    }
      
      write.csv(sig_data,paste0(ms_fasta_results,fasta_name,"_significant_peptides.csv"),row.names = FALSE)
      sig_data<-read.csv(paste0(ms_fasta_results,fasta_name,"_significant_peptides.csv"))
      print(paste(fasta_name,"signifcant cancer SEARCH, different sequences/different genes: ", length(levels(sig_data$peptide)),"/",length(levels(sig_data$genenames))))
      all_sigData<-rbind.data.frame(all_sigData,sig_data)
    
  }
  write.csv(all_sigData,paste0(result_path,"all_significant_peptides.csv"),row.names = FALSE)
  all_sigData<-read.csv(paste0(result_path,"all_significant_peptides.csv"))
  data_applied_isoform<-apply_isoform(all_sigData)
  final_peptides<-get_one_isoform(data_applied_isoform)
  if(dim(final_peptides)[1]!=0){
    other_splice_types<-gene_other_splicetypes()
  }
  
  
  return(final_peptides)
  
}

peptides<-main()






